<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DelaunayMeshes</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>DelaunayMeshes</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="UserGuide.html">User Guide</a></li><li class="current"><a class="toctext" href="index.html">API</a><ul class="internal"><li><a class="toctext" href="#DelaunayMeshes-1">DelaunayMeshes</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">API</a></li></ul><a class="edit-page" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h2><a class="nav-anchor" id="DelaunayMeshes-1" href="#DelaunayMeshes-1">DelaunayMeshes</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes" href="#DelaunayMeshes"><code>DelaunayMeshes</code></a> — <span class="docstring-category">Module</span>.</div><div><p>This module provides high-level functionality to generate, manage and refine meshes based on constrained Delaunay triangulations.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/DelaunayMeshes.jl#L1-L4">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.addconstraint!-Tuple{DelaunayMeshes.Mesh,Array{Int64,1}}" href="#DelaunayMeshes.addconstraint!-Tuple{DelaunayMeshes.Mesh,Array{Int64,1}}"><code>DelaunayMeshes.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">addconstraint!(mesh::Mesh, vertices::Vector{Int})</code></pre><p>Adds a constraint, given as a list of existing vertices, into the DelaunayMeshes.</p><p><strong>Remarks</strong></p><ul><li><p>Constraints are closed polygons. A constraint edge from the last vertex to the first vertex is automatically inserted to ensure closure.</p></li><li><p>All faces interior of the constrained region are marked as &quot;exterior&quot; to the DelaunayMeshes. A face is interior to the constrained region if it is located to the right of the given constraint polygon (i.e. the constraint vertices circle the interior region counter-clockwise).</p></li><li><p>Constraint edges must not intersect. For performance reasons, this is not checked.</p></li><li><p>Any vertex of the triangulation can intersect either zero or two constraint edges.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/DelaunayMesh.jl#L197-L212">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.getvoronoivertices-Tuple{DelaunayMeshes.Mesh}" href="#DelaunayMeshes.getvoronoivertices-Tuple{DelaunayMeshes.Mesh}"><code>DelaunayMeshes.getvoronoivertices</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getvoronoivertices(mesh::Mesh)</code></pre><p>Computes the Voronoi vertices of the given DelaunayMeshes.</p><p><strong>Remarks</strong></p><ul><li><p>The results are cached but need to be re-computed whenever a new vertex or a new constraint is pushed into the DelaunayMeshes.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/DelaunayMesh.jl#L56-L64">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.beta" href="#DelaunayMeshes.beta"><code>DelaunayMeshes.beta</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Maximal ratio of circumcircle radius and length of shortest edge before  a triangle is considered bad.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/PostProcess.jl#L1-L4">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.ConstraintType" href="#DelaunayMeshes.ConstraintType"><code>DelaunayMeshes.ConstraintType</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Implementation of the QuadEdge-Datastructure. [Guibas85]_</p><p>.. [Guibas85] Leonidas Guibas and Jorge Stolfi, Primitives for the manipulation of general subdivisions and the computation of Voronoi diagrams, <em>ACM Transactions on Graphics</em>, 4(2), 1985, 75-123.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L1-L6">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.DelaunayTesselation-Tuple{}" href="#DelaunayMeshes.DelaunayTesselation-Tuple{}"><code>DelaunayMeshes.DelaunayTesselation</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">DelaunayTesselation()</code></pre><p>Creates an initial triangulation consisting of a maximal triangle and the corresponding faces.</p><p><strong>Remarks</strong></p><ul><li><p>The inner face coordinates are the centroid of the triangle.</p></li><li><p>The outer face coordinates are located at <span>$(∞, ∞)$</span>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L8-L17">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.Mesh" href="#DelaunayMeshes.Mesh"><code>DelaunayMeshes.Mesh</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Defines a mesh. A mesh consists of a bounding box providing bounds to the vertex coordinates, constraints consisting of closed polygons and the corresponding Delaunay tesselation.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/DelaunayMesh.jl#L28-L32">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.Triangle" href="#DelaunayMeshes.Triangle"><code>DelaunayMeshes.Triangle</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Represents a triangle. It can be constructed from three vertices or a starting edge. It finds the edges enclosing the triangle and its inner face.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L655-L658">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{DiffEqPDEBase.SimpleFEMMesh},DelaunayMeshes.Mesh}" href="#Base.convert-Tuple{Type{DiffEqPDEBase.SimpleFEMMesh},DelaunayMeshes.Mesh}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">convert(::Type{DiffEqPDEBase.SimpleFEMMesh}, mesh::Mesh)</code></pre><p>Converts the given mesh to a format that can be used by the FEM-solvers.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/DelaunayMesh.jl#L242-L246">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{DelaunayMeshes.Mesh,Array{Float64,2}}" href="#Base.push!-Tuple{DelaunayMeshes.Mesh,Array{Float64,2}}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">push!(mesh::Mesh, points::Array{Float64, 2})</code></pre><p>Inserts a number of vertices into the mesh.</p><p><strong>Remarks</strong></p><ul><li><p>If the mesh was initialized without a bounding box, it is determined by the first set of vertices that are pushed into the triangualation. All consecutive push operations cannot insert vertices that exceed the bounding box limits</p></li><li><p>New faces that are created by a push operation are marked as interior by default, i.e. it is forbidden to push vertices into an exterior region.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/DelaunayMesh.jl#L125-L137">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.base-Tuple{Int64}" href="#DelaunayMeshes.base-Tuple{Int64}"><code>DelaunayMeshes.base</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">base(ei::Int)</code></pre><p>Computes base index of index <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L43-L47">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.check_triangle-Tuple{DelaunayMeshes.Mesh,DelaunayMeshes.Triangle}" href="#DelaunayMeshes.check_triangle-Tuple{DelaunayMeshes.Mesh,DelaunayMeshes.Triangle}"><code>DelaunayMeshes.check_triangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">check_triangle(mesh::Mesh, tri::Triangle)</code></pre><p>Checks if the triangle satisfies the quality measure <span>$r/ar{pq} le eta$</span>, with <span>$r$</span> the radius of the circumcircle and <span>$ar{pq}$</span> the length of its shortest edge.</p><p><strong>Returns</strong></p><ul><li><p><code>true</code>, if the triangle satisfies the quality measure.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/PostProcess.jl#L205-L214">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.checkconvexityquadriliteral-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Int64,1}}" href="#DelaunayMeshes.checkconvexityquadriliteral-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Int64,1}}"><code>DelaunayMeshes.checkconvexityquadriliteral</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">checkconvexityquadriliteral(sd::DelaunayTesselation, vertices::Vector{Int})</code></pre><p>Checks if the given quadriliteral is strictly convex.</p><p><strong>Remarks</strong></p><ul><li><p>The end points of the quadriliteral must be given in CCW order</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L524-L531">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.compute_circumcenter_radius-Tuple{DelaunayMeshes.Mesh,Int64,Int64,Int64}" href="#DelaunayMeshes.compute_circumcenter_radius-Tuple{DelaunayMeshes.Mesh,Int64,Int64,Int64}"><code>DelaunayMeshes.compute_circumcenter_radius</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">compute_circumcenter_radius(mesh::Mesh, p::VertexIndex, r::VertexIndex, q::VertexIndex)</code></pre><p>Computes the position and radius of the triangle circumcenter.</p><p><strong>Returns</strong></p><ul><li><p>cx, cy, rs with <span>$c_x$</span>, <span>$c_y$</span> the position and <span>$r_s$</span> the radius square of the circum center.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/PostProcess.jl#L9-L16">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.compute_offcenter-Tuple{DelaunayMeshes.Mesh,Int64,Int64,Int64}" href="#DelaunayMeshes.compute_offcenter-Tuple{DelaunayMeshes.Mesh,Int64,Int64,Int64}"><code>DelaunayMeshes.compute_offcenter</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">compute_offcenter(mesh:Mesh, p::VertexIndex, q::VertexIndex, r::VertexIndex)</code></pre><p>Computes position of offcenter<a href="#footnote-1">[1]</a> for given triangle <span>$p - q - r$</span>.</p><p><strong>Remarks</strong></p><ul><li><p><span>$p - q$</span> must be the shortest edge of the triangle, i.e. the smallest angle is located at <span>$r$</span>.</p></li></ul><p><strong>References</strong></p><p><a href="#footnote-1">[1]</a> Alper Üngör (2009). Off-centers: A new type of Steiner points for computing size-optimal quality-guaranteed Delaunay triangulations, Computational Geometry, <em>42</em> (2)</p><p><img src="SteinerPoint.svg" alt="SteinerPoint"/></p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/PostProcess.jl#L35-L47">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.computescaleandshiftfromboundingbox-Tuple{Array{Float64,1}}" href="#DelaunayMeshes.computescaleandshiftfromboundingbox-Tuple{Array{Float64,1}}"><code>DelaunayMeshes.computescaleandshiftfromboundingbox</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">computescaleandshiftfromboundingbox(boundingBox::Vector{Float64})</code></pre><p>Computes the scale and horizontal/vertical shift from a given bounding box. This establishes an aspect-ratio-conserving transformation from the given bounding box into a square that fits comfortably into the outer bounding triangle of the DelaunayMeshes. The square (blue) fills ten per cent of the maximally inscribed square (dashed).</p><p><img src="inscribedsquare.svg" alt="inscribed"/></p><p>Specifically, if <span>$(c_x, c_y)$</span> denote the center of the bounding box and <span>$Delta = max((x_mathrm{max} - x_mathrm{min}), (x_mathrm{max} - x_mathrm{min}))$</span> is the maximum extent of the bounding box, then the coordinate transformation to the new primed coordinates is given by <span>$(x&#39;, y&#39;) = 0.1 (x - c_x, y - c_y)/Delta + (c_x&#39;, c_y&#39;)$</span>, where <span>$(c_x&#39;, c_y&#39;) = (1.5, 1.25)$</span> denotes the center of the inscribed square.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/DelaunayMesh.jl#L3-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.connect!-Tuple{DelaunayMeshes.SubDivision{T},Int64,Int64,T}" href="#DelaunayMeshes.connect!-Tuple{DelaunayMeshes.SubDivision{T},Int64,Int64,T}"><code>DelaunayMeshes.connect!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">connect!{T}(sd::SubDivision, ai::Int, bi::Int, newFace::T)</code></pre><p>Connects the end vertex of edge <code>ai</code> to the start vertex <code>bi</code>.</p><p><strong>Remarks</strong></p><ul><li><p>This operation adds another face to the subdivision. The new face will be to the right of the new edge and will be correctly assigned to all adjacent edges.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L312-L321">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.dest-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.dest-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.dest</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dest(sd::SubDivision, ei::Int)</code></pre><p>Gets the index of the destination vertex of edge index <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L110-L114">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.dprev-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.dprev-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.dprev</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dprev(sd::SubDivision, ei::Int)</code></pre><p>Gets the next edge ending at the destination of <code>ei</code> in clockwise direction.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L139-L143">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.endpoints!-Tuple{DelaunayMeshes.SubDivision,Int64,Int64,Int64,Int64,Int64}" href="#DelaunayMeshes.endpoints!-Tuple{DelaunayMeshes.SubDivision,Int64,Int64,Int64,Int64,Int64}"><code>DelaunayMeshes.endpoints!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">endpoints!(sd::SubDivision, ei::Int, vio::Int, vid::Int, lfi::Int, rfi::Int)</code></pre><p>Assigns the start(end) point <code>vio</code>(<code>vid</code>) and the left(right) faces <code>lfi</code>(<code>rfi</code>) to given edge <code>ei</code>.</p><p><strong>Remarks</strong></p><ul><li><p>The start(end) points of the symmetric and symmetric dual edges are assigned correctly.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L235-L244">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.findintersectingedges-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64}" href="#DelaunayMeshes.findintersectingedges-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64}"><code>DelaunayMeshes.findintersectingedges</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findintersectingedges(sd::DelaunayTesselation, v1::Int, v2::Int, eg::Int)</code></pre><p>Finds all edges of the given tesselation that intersect with a virtual edge from <code>v1</code> to <code>v2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L477-L482">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.get_shortest_edge-Tuple{DelaunayMeshes.Mesh,Int64,Int64,Int64}" href="#DelaunayMeshes.get_shortest_edge-Tuple{DelaunayMeshes.Mesh,Int64,Int64,Int64}"><code>DelaunayMeshes.get_shortest_edge</code></a> — <span class="docstring-category">Method</span>.</div><div><p>&quot;     get_shortest_edge(mesh::Mesh, ai::VertexIndex, bi::VertexIndex, ci::VertexIndex)</p><p>Given a triangle with CCW-ordered vertices <code>ai</code> - <code>bi</code> - <code>ci</code>, it computes the edge length and returns a sorted tuple <code>p</code> - <code>q</code> - <code>r</code> such that the triangle <span>$p - q - r$</span> has its shortest edge between <code>p</code> and <code>q</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/PostProcess.jl#L105-L112">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.getadjacentquadriliteral-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64}" href="#DelaunayMeshes.getadjacentquadriliteral-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64}"><code>DelaunayMeshes.getadjacentquadriliteral</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getadjacentquadriliteral(sd::DelaunayTesselation, ei::Int)</code></pre><p>Gets vertices of quadriliteral formed by the two triangles adjacent to given edge in ccw order.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L538-L542">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.getalltriangles-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}}}" href="#DelaunayMeshes.getalltriangles-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}}}"><code>DelaunayMeshes.getalltriangles</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getalltriangles(sd::SubDivision)</code></pre><p>Returns all triangles as edge lists.</p><p><strong>Remarks</strong></p><ul><li><p>The boundary edges are included.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L29-L36">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.getfacesinsideregion-Tuple{DelaunayMeshes.Mesh,Int64}" href="#DelaunayMeshes.getfacesinsideregion-Tuple{DelaunayMeshes.Mesh,Int64}"><code>DelaunayMeshes.getfacesinsideregion</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getfacesinsideregion(mesh::Mesh, ei::Int)</code></pre><p>Finds all faces that are located inside the same region as the face identified by <code>org(ei)</code>.</p><p><strong>Remarks</strong></p><ul><li><p>The algorithm performs a breadth-first search over all adjacent triangles while omitting triangles that requires crossing a boundary.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/DelaunayMesh.jl#L157-L166">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.incircle-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64,Int64}" href="#DelaunayMeshes.incircle-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64,Int64}"><code>DelaunayMeshes.incircle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">incircle(sd::DelaunayTesselation, v1::Int, v2::Int, v3::Int, v4::Int)</code></pre><p>Tests if the vertex <code>v4</code> is strictly inside the circumcircle of the triangle <code>v1</code>-<code>v2</code>-<code>v3</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L389-L394">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.insertconstraint!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64}" href="#DelaunayMeshes.insertconstraint!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64}"><code>DelaunayMeshes.insertconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">insertconstraint!(sd::DelaunayTesselation, v1::Int, v2::Int)</code></pre><p>Inserts constraint going from <code>v1</code> to <code>v2</code>.</p><p><strong>Remarks</strong></p><ul><li><p>The constrained region is assumed to be on the right of the directed edge.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L626-L634">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.insertpoint!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}" href="#DelaunayMeshes.insertpoint!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}"><code>DelaunayMeshes.insertpoint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">insertpoint!(sd::DelaunayTesselation, x::Point, ei::Int)</code></pre><p>Inserts a given point into an existing DelaunayMeshes.</p><p><strong>Remarks</strong></p><ul><li><p>The algorithm identifies the triangle in the existing triangulation that contains the vertex to be inserted, taking &lt;paramref name =&quot;ei&quot;/&gt; as start point for the search. It then connects the newly-inserted point to all vertices of the enclosing triangle.</p></li><li><p>If an existing vertex is already located at the point coordinates an error is thrown.</p></li></ul><p>#Returns</p><ul><li><p>new edge, last edge of target triangle (lnext(lastEdge) = newEdge)</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L317-L331">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.invrot-Tuple{Int64}" href="#DelaunayMeshes.invrot-Tuple{Int64}"><code>DelaunayMeshes.invrot</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">invrot(ei::Int)</code></pre><p>Inverse operation of <code>rot(ei)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L85-L89">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.lface-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.lface-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.lface</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lface(sd::SubDivision, ei::Int)</code></pre><p>Returns the index to face left of given edge <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L168-L172">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.lnext-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.lnext-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.lnext</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lnext(sd::SubDivision, ei::Int)</code></pre><p>Gets the next edge around the left face of <code>ei</code> and starting at destination of <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L148-L153">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.locatevertex-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}" href="#DelaunayMeshes.locatevertex-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}"><code>DelaunayMeshes.locatevertex</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">locatevertex(sd::DelaunayTesselation, x::Point, ei::Int)</code></pre><p>Locates point <code>x</code> in existing subdivision by traversing the triangulation starting at edge <code>ei</code>.</p><p><strong>Remarks</strong></p><ul><li><p>The point coordinates must be exactly inside the enclosing triangle.</p></li><li><p>The algorithm used here [Brown]_ is more stable than the original version</p></li></ul><p>.. [Brown] Brown, Faigle: A robust efficient algorithm for point location in triangulations</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L238-L249">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.lprev-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.lprev-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.lprev</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lprev(sd::SubDivision, ei::Int)</code></pre><p>Gets the previous edge around the left face of <code>ei</code> and ending at source of <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L158-L163">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.makeedge!-Tuple{DelaunayMeshes.SubDivision}" href="#DelaunayMeshes.makeedge!-Tuple{DelaunayMeshes.SubDivision}"><code>DelaunayMeshes.makeedge!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">makeedge!(sd::SubDivision)</code></pre><p>Creates an empty edge and adds it to given SubDivision.</p><p>#returns</p><ul><li><p>Number of newly-added edge.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L24-L31">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.onext-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.onext-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.onext</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">onext(sd::SubDivision, ei::Int)</code></pre><p>Gets the next edge starting at the origin of <code>ei</code> in counter-clockwise direction.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L120-L125">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.oprev-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.oprev-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.oprev</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">oprev(sd::SubDivision, ei::Int)</code></pre><p>Gets the next edge starting at the origin of <code>ei</code> in clockwise direction.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L130-L134">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.org-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.org-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.org</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">org(sd::SubDivision, ei::Int)</code></pre><p>Gets the index of the origin vertex of edge index <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L101-L105">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.pointsintersect-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}" href="#DelaunayMeshes.pointsintersect-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>DelaunayMeshes.pointsintersect</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pointsintersect(p1::Point, q1::Point, p2::Point, q2::Point)</code></pre><p>Checks if line segments given by their end points intersect.</p><p><strong>Remarks</strong></p><ul><li><p>Taken from geeksforgeeks.org/check-if-two-given-line-segments-intersect</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L196-L203">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.refine_triangle-Tuple{DelaunayMeshes.Mesh,DelaunayMeshes.Triangle}" href="#DelaunayMeshes.refine_triangle-Tuple{DelaunayMeshes.Mesh,DelaunayMeshes.Triangle}"><code>DelaunayMeshes.refine_triangle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">function refine_triangle(mesh::Mesh, tri::Triangle)</code></pre><p>Refines the triangle located to the left of edge <code>ei</code> by adding a new vertex at the offcenter or the midpoint of encroached edges.</p><p><strong>Remarks</strong></p><ul><li><p>If a new vertex at the off-center of the triangle does not encroach any segments it is inserted at the off-center.</p></li><li><p>Otherwise, a new vertex is inserted at the midpoint of each edge that the off-center would encroach on. try</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/PostProcess.jl#L142-L154">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.refine_valid_triangles!-Tuple{DelaunayMeshes.Mesh}" href="#DelaunayMeshes.refine_valid_triangles!-Tuple{DelaunayMeshes.Mesh}"><code>DelaunayMeshes.refine_valid_triangles!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">refine_valid_triangles!(mesh::</code></pre><p>Gets the first triangle that does not satisfy the quality measure or <code>null</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/PostProcess.jl#L241-L245">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.removedeletededges!-Tuple{DelaunayMeshes.SubDivision}" href="#DelaunayMeshes.removedeletededges!-Tuple{DelaunayMeshes.SubDivision}"><code>DelaunayMeshes.removedeletededges!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">removedeletededges!(sd::SubDivision)</code></pre><p>Removes all edges that were marked as deleted in DelaunayMeshes.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L383-L387">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.removeintersectingedges!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Array{Int64,1}}" href="#DelaunayMeshes.removeintersectingedges!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Array{Int64,1}}"><code>DelaunayMeshes.removeintersectingedges!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">removeintersectingedges!(
  sd::DelaunayTesselation, v1::Int, v2::Int, intersecting::Vector{Int})</code></pre><p>Removes all intersecting edges by iteratively swapping diagonals of enclosing quadriliterals.</p><p><strong>Remarks</strong></p><ul><li><p>For details see Sloan: A fast algorithm for generating constrained Delaunay triangulations.</p></li><li><p>Returns the index of the constraint edge</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L555-L564">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.restoredelaunay!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64}" href="#DelaunayMeshes.restoredelaunay!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64}"><code>DelaunayMeshes.restoredelaunay!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">restoredelaunay!(sd::DelaunayTesselation, ei::Int, si::Int, xi::Int)</code></pre><p>Restores Delaunay constraint for edge structure by swapping edges of adjacent triangles.</p><p><strong>Remarks</strong></p><ul><li><p>It examines all triangles to check if the new vertex <code>xi</code> is inside its circumcircle.</p></li><li><p>The algorithm cycles through all adjacent edges starting at <code>startEdge</code> and stopping at <code>stopEdge</code>.</p></li><li><p>If an edge is swapped, its neighbours are examined as well.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L405-L416">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.rface-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.rface-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.rface</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lface(sd::SubDivision, ei::Int)</code></pre><p>Returns the index to face left of given edge <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L178-L182">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.rightof-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}" href="#DelaunayMeshes.rightof-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}"><code>DelaunayMeshes.rightof</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">rightof(sd::DelaunayTesselation, vi::Int, ei::Int)
rightof(sd::DelaunayTesselation, x::Point, ei::Int)</code></pre><p>Computes the location of vertex <code>vi</code> relative to line defined by <code>ei</code>.</p><p><strong>Remarks</strong></p><ul><li><p>Internally, the computation is forwarded to <code>GeometricalPredicates.orientation</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>True, if <code>vi</code> is located to the right of the edge</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L110-L122">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.rot-Tuple{Int64}" href="#DelaunayMeshes.rot-Tuple{Int64}"><code>DelaunayMeshes.rot</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">rot(ei::Int)</code></pre><p>Computes the index of the dual edge to index <code>ei</code>.</p><p><strong>Remarks</strong></p><ul><li><p>The dual edge is obtained by rotating <code>ei</code> counter-clockwise by 90 degrees.</p></li><li><p>The start(end) points of the dual edge can be interpreted as representing the right(left) face.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L66-L75">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.splice!-Tuple{DelaunayMeshes.SubDivision,Int64,Int64}" href="#DelaunayMeshes.splice!-Tuple{DelaunayMeshes.SubDivision,Int64,Int64}"><code>DelaunayMeshes.splice!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">splice!(sd::SubDivision, ai::Int, bi::Int)</code></pre><p>Combines or splices two given edge rings <code>ai</code> and <code>bi</code>.</p><p><strong>Remarks</strong></p><ul><li><p>If the origins of <code>ai</code> and <code>bi</code> are identical, it cuts the two edge rings</p></li><li><p>If the origins differ, it joins the two edge rings</p></li><li><p>After the operation, the new edge rings satisfy the identities <code>onext(ai) = onext(bi)</code> and <code>onext(bi) = onext(ai)</code> and the corresponding identities for the dual rings.</p></li><li><p>The origins of the edges are neither evaluated nor are theyaffected by this operation and need to be updated manually.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L263-L276">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.swap!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64}" href="#DelaunayMeshes.swap!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64}"><code>DelaunayMeshes.swap!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">swap!(sd::DelaunayTesselation, ei::Int)</code></pre><p>Swaps edge <code>ei</code> such that the new edge connects the apexes of the triangles adjacent to the old edge.</p><p><strong>Remarks</strong></p><ul><li><p>Specifially, if <code>a = oprev(ei)</code> and <code>b = oprev(sym(ei))</code> before the swap, then the edge <code>ei</code> will connect <code>dest(a)</code> with <code>dest(b)</code> after the swap.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/Triangulation.jl#L70-L79">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.sym-Tuple{Int64}" href="#DelaunayMeshes.sym-Tuple{Int64}"><code>DelaunayMeshes.sym</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sym(ei::Int)</code></pre><p>Computes index of symmetric index <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/QuadEdge.jl#L52-L56">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.vertex_encroaches_segment-Tuple{DelaunayMeshes.Mesh,Int64,Array{Float64,1}}" href="#DelaunayMeshes.vertex_encroaches_segment-Tuple{DelaunayMeshes.Mesh,Int64,Array{Float64,1}}"><code>DelaunayMeshes.vertex_encroaches_segment</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">vertex_encroaches_segment(mesh::Mesh, ei::Int, vertex::Point)</code></pre><p>Checks if a potential vertex encroaches the segment denoted by <code>ei</code>.</p><p><strong>Remarks</strong></p><ul><li><p>If edge <code>ei</code> is not a segment, i.e. not marked as a boundary, it always returns <code>false</code></p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/6c5fe6a361b17d4d2cca13c96eec59f60652bbd9/src/PostProcess.jl#L79-L87">source</a><br/></section><footer><hr/><a class="previous" href="UserGuide.html"><span class="direction">Previous</span><span class="title">User Guide</span></a></footer></article></body></html>
