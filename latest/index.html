<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · DelaunayMeshes</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.5.0/styles/default.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Ubuntu+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="assets/documenter.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="../versions.js"></script></head><body><nav class="toc"><h1>DelaunayMeshes</h1><form class="search" action="search.html"><select id="version-selector" onChange="window.location.href=this.value"><option value="#" selected="selected" disabled="disabled">Version</option></select><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="UserGuide.html">User Guide</a></li><li class="current"><a class="toctext" href="index.html">API</a><ul class="internal"><li><a class="toctext" href="#DelaunayMeshes-1">DelaunayMeshes</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">API</a></li></ul><a class="edit-page" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/></header><h2><a class="nav-anchor" id="DelaunayMeshes-1" href="#DelaunayMeshes-1">DelaunayMeshes</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes" href="#DelaunayMeshes"><code>DelaunayMeshes</code></a> — <span class="docstring-category">Module</span>.</div><div><p>This module provides high-level functionality to generate, manage and refine meshes based on constrained Delaunay triangulations.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/DelaunayMeshes.jl#L1-L4">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.addconstraint!-Tuple{DelaunayMeshes.Mesh,Array{Int64,1}}" href="#DelaunayMeshes.addconstraint!-Tuple{DelaunayMeshes.Mesh,Array{Int64,1}}"><code>DelaunayMeshes.addconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">addconstraint!(mesh::Mesh, vertices::Vector{Int})</code></pre><p>Adds a constraint, given as a list of existing vertices, into the DelaunayMeshes.</p><p><strong>Remarks</strong></p><ul><li><p>Constraints are closed polygons. A constraint edge from the last vertex to the first vertex is automatically inserted to ensure closure.</p></li><li><p>All faces interior of the constrained region are marked as &quot;exterior&quot; to the DelaunayMeshes. A face is interior to the constrained region if it is located to the right of the given constraint polygon (i.e. the constraint vertices circle the interior region counter-clockwise).</p></li><li><p>Constraint edges must not intersect. For performance reasons, this is not checked.</p></li><li><p>Any vertex of the triangulation can intersect either zero or two constraint edges.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/DelaunayMesh.jl#L193-L208">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.getvoronoivertices-Tuple{DelaunayMeshes.Mesh}" href="#DelaunayMeshes.getvoronoivertices-Tuple{DelaunayMeshes.Mesh}"><code>DelaunayMeshes.getvoronoivertices</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getvoronoivertices(mesh::Mesh)</code></pre><p>Computes the Voronoi vertices of the given DelaunayMeshes.</p><p><strong>Remarks</strong></p><ul><li><p>The results are cached but need to be re-computed whenever a new vertex or a new constraint is pushed into the DelaunayMeshes.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/DelaunayMesh.jl#L56-L64">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.beta" href="#DelaunayMeshes.beta"><code>DelaunayMeshes.beta</code></a> — <span class="docstring-category">Constant</span>.</div><div><p>Maximal ratio of circumcircle radius and length of shortest edge before  a triangle is considered bad.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/PostProcess.jl#L1-L4">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.ConstraintType" href="#DelaunayMeshes.ConstraintType"><code>DelaunayMeshes.ConstraintType</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Implementation of the QuadEdge-Datastructure. [Guibas85]_</p><p>.. [Guibas85] Leonidas Guibas and Jorge Stolfi, Primitives for the manipulation of general subdivisions and the computation of Voronoi diagrams, <em>ACM Transactions on Graphics</em>, 4(2), 1985, 75-123.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L1-L6">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.DelaunayTesselation-Tuple{}" href="#DelaunayMeshes.DelaunayTesselation-Tuple{}"><code>DelaunayMeshes.DelaunayTesselation</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">DelaunayTesselation()</code></pre><p>Creates an initial triangulation consisting of a maximal triangle and the corresponding faces.</p><p><strong>Remarks</strong></p><ul><li><p>The inner face coordinates are the centroid of the triangle.</p></li><li><p>The outer face coordinates are located at <span>$(∞, ∞)$</span>.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L16-L25">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.Mesh" href="#DelaunayMeshes.Mesh"><code>DelaunayMeshes.Mesh</code></a> — <span class="docstring-category">Type</span>.</div><div><p>Defines a mesh. A mesh consists of a bounding box providing bounds to the vertex coordinates, constraints consisting of closed polygons and the corresponding Delaunay tesselation.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/DelaunayMesh.jl#L28-L32">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.convert-Tuple{Type{DiffEqPDEBase.SimpleFEMMesh},DelaunayMeshes.Mesh}" href="#Base.convert-Tuple{Type{DiffEqPDEBase.SimpleFEMMesh},DelaunayMeshes.Mesh}"><code>Base.convert</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">convert(::Type{DiffEqPDEBase.SimpleFEMMesh}, mesh::Mesh)</code></pre><p>Converts the given mesh to a format that can be used by the FEM-solvers.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/DelaunayMesh.jl#L238-L242">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.push!-Tuple{DelaunayMeshes.Mesh,Array{Float64,2}}" href="#Base.push!-Tuple{DelaunayMeshes.Mesh,Array{Float64,2}}"><code>Base.push!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">push!(mesh::Mesh, points::Array{Float64, 2})</code></pre><p>Inserts a number of vertices into the mesh.</p><p><strong>Remarks</strong></p><ul><li><p>If the mesh was initialized without a bounding box, it is determined by the first set of vertices that are pushed into the triangualation. All consecutive push operations cannot insert vertices that exceed the bounding box limits</p></li><li><p>New faces that are created by a push operation are marked as interior by default, i.e. it is forbidden to push vertices into an exterior region.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/DelaunayMesh.jl#L112-L124">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.base-Tuple{Int64}" href="#DelaunayMeshes.base-Tuple{Int64}"><code>DelaunayMeshes.base</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">base(ei::Int)</code></pre><p>Computes base index of index <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L42-L46">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.checkconvexityquadriliteral-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Int64,1}}" href="#DelaunayMeshes.checkconvexityquadriliteral-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Int64,1}}"><code>DelaunayMeshes.checkconvexityquadriliteral</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">checkconvexityquadriliteral(sd::DelaunayTesselation, vertices::Vector{Int})</code></pre><p>Checks if the given quadriliteral is strictly convex.</p><p><strong>Remarks</strong></p><ul><li><p>The end points of the quadriliteral must be given in CCW order</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L497-L504">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.compute_circumcenter_radius-Tuple{DelaunayMeshes.Mesh,Int64,Int64,Int64}" href="#DelaunayMeshes.compute_circumcenter_radius-Tuple{DelaunayMeshes.Mesh,Int64,Int64,Int64}"><code>DelaunayMeshes.compute_circumcenter_radius</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">compute_circumcenter_radius(mesh::Mesh, p::VertexIndex, r::VertexIndex, q::VertexIndex)</code></pre><p>Computes the position and radius of the triangle circumcenter.</p><p><strong>Returns</strong></p><ul><li><p>cx, cy, rs with <span>$c_x$</span>, <span>$c_y$</span> the position and <span>$r_s$</span> the radius square of the circum center.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/PostProcess.jl#L7-L14">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.compute_offcenter-Tuple{DelaunayMeshes.Mesh,Int64,Int64,Int64}" href="#DelaunayMeshes.compute_offcenter-Tuple{DelaunayMeshes.Mesh,Int64,Int64,Int64}"><code>DelaunayMeshes.compute_offcenter</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">compute_offcenter(mesh:Mesh, p::VertexIndex, q::VertexIndex, r::VertexIndex)</code></pre><p>Computes position of offcenter<a href="#footnote-1">[1]</a> for given triangle <span>$p - q - r$</span>.</p><p><strong>Remarks</strong></p><ul><li><p><span>$p - q$</span> must be the shortest edge of the triangle, i.e. the smallest angle is located at <span>$r$</span>.</p></li></ul><p><strong>References</strong></p><p><a href="#footnote-1">[1]</a> Alper Üngör (2009). Off-centers: A new type of Steiner points for computing size-optimal quality-guaranteed Delaunay triangulations, Computational Geometry, <em>42</em> (2)</p><p><img src="SteinerPoint.svg" alt="SteinerPoint"/></p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/PostProcess.jl#L33-L45">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.computescaleandshiftfromboundingbox-Tuple{Array{Float64,1}}" href="#DelaunayMeshes.computescaleandshiftfromboundingbox-Tuple{Array{Float64,1}}"><code>DelaunayMeshes.computescaleandshiftfromboundingbox</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">computescaleandshiftfromboundingbox(boundingBox::Vector{Float64})</code></pre><p>Computes the scale and horizontal/vertical shift from a given bounding box. This establishes an aspect-ratio-conserving transformation from the given bounding box into a square that fits comfortably into the outer bounding triangle of the DelaunayMeshes. The square (blue) fills ten per cent of the maximally inscribed square (dashed).</p><p><img src="inscribedsquare.svg" alt="inscribed"/></p><p>Specifically, if <span>$(c_x, c_y)$</span> denote the center of the bounding box and <span>$Delta = max((x_mathrm{max} - x_mathrm{min}), (x_mathrm{max} - x_mathrm{min}))$</span> is the maximum extent of the bounding box, then the coordinate transformation to the new primed coordinates is given by <span>$(x&#39;, y&#39;) = 0.1 (x - c_x, y - c_y)/Delta + (c_x&#39;, c_y&#39;)$</span>, where <span>$(c_x&#39;, c_y&#39;) = (1.5, 1.25)$</span> denotes the center of the inscribed square.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/DelaunayMesh.jl#L3-L20">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.connect!-Tuple{DelaunayMeshes.SubDivision{T},Int64,Int64,T}" href="#DelaunayMeshes.connect!-Tuple{DelaunayMeshes.SubDivision{T},Int64,Int64,T}"><code>DelaunayMeshes.connect!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">connect!{T}(sd::SubDivision, ai::Int, bi::Int, newFace::T)</code></pre><p>Connects the end vertex of edge <code>ai</code> to the start vertex <code>bi</code>.</p><p><strong>Remarks</strong></p><ul><li><p>This operation adds another face to the subdivision. The new face will be to the right of the new edge and will be correctly assigned to all adjacent edges.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L311-L320">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.dest-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.dest-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.dest</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dest(sd::SubDivision, ei::Int)</code></pre><p>Gets the index of the destination vertex of edge index <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L109-L113">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.dprev-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.dprev-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.dprev</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">dprev(sd::SubDivision, ei::Int)</code></pre><p>Gets the next edge ending at the destination of <code>ei</code> in clockwise direction.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L138-L142">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.endpoints!-Tuple{DelaunayMeshes.SubDivision,Int64,Int64,Int64,Int64,Int64}" href="#DelaunayMeshes.endpoints!-Tuple{DelaunayMeshes.SubDivision,Int64,Int64,Int64,Int64,Int64}"><code>DelaunayMeshes.endpoints!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">endpoints!(sd::SubDivision, ei::Int, vio::Int, vid::Int, lfi::Int, rfi::Int)</code></pre><p>Assigns the start(end) point <code>vio</code>(<code>vid</code>) and the left(right) faces <code>lfi</code>(<code>rfi</code>) to given edge <code>ei</code>.</p><p><strong>Remarks</strong></p><ul><li><p>The start(end) points of the symmetric and symmetric dual edges are assigned correctly.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L234-L243">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.findintersectingedges-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64}" href="#DelaunayMeshes.findintersectingedges-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64}"><code>DelaunayMeshes.findintersectingedges</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">findintersectingedges(sd::DelaunayTesselation, v1::Int, v2::Int, eg::Int)</code></pre><p>Finds all edges of the given tesselation that intersect with a virtual edge from <code>v1</code> to <code>v2</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L450-L455">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.getadjacentquadriliteral-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64}" href="#DelaunayMeshes.getadjacentquadriliteral-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64}"><code>DelaunayMeshes.getadjacentquadriliteral</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getadjacentquadriliteral(sd::DelaunayTesselation, ei::Int)</code></pre><p>Gets vertices of quadriliteral formed by the two triangles adjacent to given edge in ccw order.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L511-L515">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.getalltriangles-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}}}" href="#DelaunayMeshes.getalltriangles-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}}}"><code>DelaunayMeshes.getalltriangles</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getalltriangles(sd::SubDivision)</code></pre><p>Returns all triangles as edge lists.</p><p><strong>Remarks</strong></p><ul><li><p>The boundary edges are included.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L37-L44">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.getfacesinsideregion-Tuple{DelaunayMeshes.Mesh,Int64}" href="#DelaunayMeshes.getfacesinsideregion-Tuple{DelaunayMeshes.Mesh,Int64}"><code>DelaunayMeshes.getfacesinsideregion</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">getfacesinsideregion(mesh::Mesh, ei::Int)</code></pre><p>Finds all faces that are located inside the same region as the face identified by <code>org(ei)</code>.</p><p><strong>Remarks</strong></p><ul><li><p>The algorithm performs a breadth-first search over all adjacent triangles while omitting triangles that requires crossing a boundary.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/DelaunayMesh.jl#L153-L162">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.incircle-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64,Int64}" href="#DelaunayMeshes.incircle-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64,Int64}"><code>DelaunayMeshes.incircle</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">incircle(sd::DelaunayTesselation, v1::Int, v2::Int, v3::Int, v4::Int)</code></pre><p>Tests if the vertex <code>v4</code> is strictly inside the circumcircle of the triangle <code>v1</code>-<code>v2</code>-<code>v3</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L361-L366">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.insertconstraint!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64}" href="#DelaunayMeshes.insertconstraint!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64}"><code>DelaunayMeshes.insertconstraint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">insertconstraint!(sd::DelaunayTesselation, v1::Int, v2::Int)</code></pre><p>Inserts constraint going from <code>v1</code> to <code>v2</code>.</p><p><strong>Remarks</strong></p><ul><li><p>The constrained region is assumed to be on the right of the directed edge.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L599-L607">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.insertpoint!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}" href="#DelaunayMeshes.insertpoint!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}"><code>DelaunayMeshes.insertpoint!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">insertpoint!(sd::DelaunayTesselation, x::Point, ei::Int)</code></pre><p>Inserts a given point into an existing DelaunayMeshes.</p><p><strong>Remarks</strong></p><ul><li><p>The algorithm identifies the triangle in the existing triangulation that contains the vertex to be inserted, taking &lt;paramref name =&quot;ei&quot;/&gt; as start point for the search. It then connects the newly-inserted point to all vertices of the enclosing triangle.</p></li><li><p>If an existing vertex is already located at the point coordinates an error is thrown.</p></li></ul><p>#Returns</p><ul><li><p>new edge, last edge of target triangle (lnext(lastEdge) = newEdge)</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L321-L335">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.invrot-Tuple{Int64}" href="#DelaunayMeshes.invrot-Tuple{Int64}"><code>DelaunayMeshes.invrot</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">invrot(ei::Int)</code></pre><p>Inverse operation of <code>rot(ei)</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L84-L88">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.lface-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.lface-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.lface</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lface(sd::SubDivision, ei::Int)</code></pre><p>Returns the index to face left of given edge <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L167-L171">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.lnext-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.lnext-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.lnext</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lnext(sd::SubDivision, ei::Int)</code></pre><p>Gets the next edge around the left face of <code>ei</code> and starting at destination of <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L147-L152">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.locatevertex-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}" href="#DelaunayMeshes.locatevertex-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}"><code>DelaunayMeshes.locatevertex</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">locatevertex(sd::DelaunayTesselation, x::Point, ei::Int)</code></pre><p>Locates point <code>x</code> in existing subdivision by traversing the triangulation starting at edge <code>ei</code>.</p><p><strong>Remarks</strong></p><ul><li><p>The point coordinates must be exactly inside the enclosing triangle.</p></li><li><p>The algorithm used here [Brown]_ is more stable than the original version</p></li></ul><p>.. [Brown] Brown, Faigle: A robust efficient algorithm for point location in triangulations</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L240-L251">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.lprev-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.lprev-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.lprev</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lprev(sd::SubDivision, ei::Int)</code></pre><p>Gets the previous edge around the left face of <code>ei</code> and ending at source of <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L157-L162">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.makeedge!-Tuple{DelaunayMeshes.SubDivision}" href="#DelaunayMeshes.makeedge!-Tuple{DelaunayMeshes.SubDivision}"><code>DelaunayMeshes.makeedge!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">makeedge!(sd::SubDivision)</code></pre><p>Creates an empty edge and adds it to given SubDivision.</p><p>#returns</p><ul><li><p>Number of newly-added edge.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L23-L30">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.onext-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.onext-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.onext</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">onext(sd::SubDivision, ei::Int)</code></pre><p>Gets the next edge starting at the origin of <code>ei</code> in counter-clockwise direction.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L119-L124">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.oprev-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.oprev-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.oprev</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">oprev(sd::SubDivision, ei::Int)</code></pre><p>Gets the next edge starting at the origin of <code>ei</code> in clockwise direction.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L129-L133">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.org-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.org-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.org</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">org(sd::SubDivision, ei::Int)</code></pre><p>Gets the index of the origin vertex of edge index <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L100-L104">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.pointsintersect-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}" href="#DelaunayMeshes.pointsintersect-Tuple{Array{Float64,1},Array{Float64,1},Array{Float64,1},Array{Float64,1}}"><code>DelaunayMeshes.pointsintersect</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">pointsintersect(p1::Point, q1::Point, p2::Point, q2::Point)</code></pre><p>Checks if line segments given by their end points intersect.</p><p><strong>Remarks</strong></p><ul><li><p>Taken from geeksforgeeks.org/check-if-two-given-line-segments-intersect</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L198-L205">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.removedeletededges!-Tuple{DelaunayMeshes.SubDivision}" href="#DelaunayMeshes.removedeletededges!-Tuple{DelaunayMeshes.SubDivision}"><code>DelaunayMeshes.removedeletededges!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">removedeletededges!(sd::SubDivision)</code></pre><p>Removes all edges that were marked as deleted in DelaunayMeshes.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L382-L386">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.removeintersectingedges!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Array{Int64,1}}" href="#DelaunayMeshes.removeintersectingedges!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Array{Int64,1}}"><code>DelaunayMeshes.removeintersectingedges!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">removeintersectingedges!(
  sd::DelaunayTesselation, v1::Int, v2::Int, intersecting::Vector{Int})</code></pre><p>Removes all intersecting edges by iteratively swapping diagonals of enclosing quadriliterals.</p><p><strong>Remarks</strong></p><ul><li><p>For details see Sloan: A fast algorithm for generating constrained Delaunay triangulations.</p></li><li><p>Returns the index of the constraint edge</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L528-L537">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.restoredelaunay!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64}" href="#DelaunayMeshes.restoredelaunay!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64,Int64,Int64}"><code>DelaunayMeshes.restoredelaunay!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">restoredelaunay!(sd::DelaunayTesselation, ei::Int, si::Int, xi::Int)</code></pre><p>Restores Delaunay constraint for edge structure by swapping edges of adjacent triangles.</p><p><strong>Remarks</strong></p><ul><li><p>It examines all triangles to check if the new vertex <code>xi</code> is inside its circumcircle.</p></li><li><p>The algorithm cycles through all adjacent edges starting at <code>startEdge</code> and stopping at <code>stopEdge</code>.</p></li><li><p>If an edge is swapped, its neighbours are examined as well.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L377-L388">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.rface-Tuple{DelaunayMeshes.SubDivision,Int64}" href="#DelaunayMeshes.rface-Tuple{DelaunayMeshes.SubDivision,Int64}"><code>DelaunayMeshes.rface</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">lface(sd::SubDivision, ei::Int)</code></pre><p>Returns the index to face left of given edge <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L177-L181">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.rightof-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}" href="#DelaunayMeshes.rightof-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Array{Float64,1},Int64}"><code>DelaunayMeshes.rightof</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">rightof(sd::DelaunayTesselation, vi::Int, ei::Int)
rightof(sd::DelaunayTesselation, x::Point, ei::Int)</code></pre><p>Computes the location of vertex <code>vi</code> relative to line defined by <code>ei</code>.</p><p><strong>Remarks</strong></p><ul><li><p>Internally, the computation is forwarded to <code>GeometricalPredicates.orientation</code>.</p></li></ul><p><strong>Returns</strong></p><ul><li><p>True, if <code>vi</code> is located to the right of the edge</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L118-L130">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.rot-Tuple{Int64}" href="#DelaunayMeshes.rot-Tuple{Int64}"><code>DelaunayMeshes.rot</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">rot(ei::Int)</code></pre><p>Computes the index of the dual edge to index <code>ei</code>.</p><p><strong>Remarks</strong></p><ul><li><p>The dual edge is obtained by rotating <code>ei</code> counter-clockwise by 90 degrees.</p></li><li><p>The start(end) points of the dual edge can be interpreted as representing the right(left) face.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L65-L74">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.splice!-Tuple{DelaunayMeshes.SubDivision,Int64,Int64}" href="#DelaunayMeshes.splice!-Tuple{DelaunayMeshes.SubDivision,Int64,Int64}"><code>DelaunayMeshes.splice!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">splice!(sd::SubDivision, ai::Int, bi::Int)</code></pre><p>Combines or splices two given edge rings <code>ai</code> and <code>bi</code>.</p><p><strong>Remarks</strong></p><ul><li><p>If the origins of <code>ai</code> and <code>bi</code> are identical, it cuts the two edge rings</p></li><li><p>If the origins differ, it joins the two edge rings</p></li><li><p>After the operation, the new edge rings satisfy the identities <code>onext(ai) = onext(bi)</code> and <code>onext(bi) = onext(ai)</code> and the corresponding identities for the dual rings.</p></li><li><p>The origins of the edges are neither evaluated nor are theyaffected by this operation and need to be updated manually.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L262-L275">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.swap!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64}" href="#DelaunayMeshes.swap!-Tuple{DelaunayMeshes.SubDivision{Array{Float64,1}},Int64}"><code>DelaunayMeshes.swap!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">swap!(sd::DelaunayTesselation, ei::Int)</code></pre><p>Swaps edge <code>ei</code> such that the new edge connects the apexes of the triangles adjacent to the old edge.</p><p><strong>Remarks</strong></p><ul><li><p>Specifially, if <code>a = oprev(ei)</code> and <code>b = oprev(sym(ei))</code> before the swap, then the edge <code>ei</code> will connect <code>dest(a)</code> with <code>dest(b)</code> after the swap.</p></li></ul></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/Triangulation.jl#L78-L87">source</a><br/></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="DelaunayMeshes.sym-Tuple{Int64}" href="#DelaunayMeshes.sym-Tuple{Int64}"><code>DelaunayMeshes.sym</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-none">sym(ei::Int)</code></pre><p>Computes index of symmetric index <code>ei</code>.</p></div><a class="source-link" target="_blank" href="https://github.com/matthias-vigelius/DelaunayMeshes.jl/tree/93824455db01374bf19c03a237a43629ef902ff4/src/QuadEdge.jl#L51-L55">source</a><br/></section><footer><hr/><a class="previous" href="UserGuide.html"><span class="direction">Previous</span><span class="title">User Guide</span></a></footer></article></body></html>
